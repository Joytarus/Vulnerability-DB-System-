const express = require('express');
const cors = require('cors');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const { PrismaClient } = require('@prisma/client');
require("dotenv").config();

const app = express();
const prisma = new PrismaClient();
const SECRET_KEY = process.env.SECRET_KEY; // You should use a more secure key and store it securely

app.use(cors());
app.use(express.json());

// Middleware to check JWT token
function authenticate(req, res, next) {
    const authHeader = req.headers.authorization;
    if (authHeader) {
        const token = authHeader.split(' ')[1];
        jwt.verify(token, SECRET_KEY, (err, user) => {
            if (err) {
                return res.sendStatus(403);
            }
            req.user = user;
            next();
        });
    } else {
        res.sendStatus(401);
    }
}

// Basic endpoint
app.get('/', (req, res) => {
    res.send('Vulnerability DB API');
});

// User Registration
app.post('/register', async(req, res) => {
    try {
        const hashedPassword = await bcrypt.hash(req.body.password, 10);
        const user = await prisma.user.create({
            data: {
                email: req.body.email,
                password: hashedPassword
            }
        });
        res.json({ message: 'User registered successfully' });
    } catch (error) {
        res.status(400).json({ error: error.message });
    }
});

// User Login
app.post('/login', async(req, res) => {
    const user = await prisma.user.findUnique({ where: { email: req.body.email } });
    if (!user) return res.status(400).json({ error: 'User not found' });

    const valid = await bcrypt.compare(req.body.password, user.password);
    if (!valid) return res.status(400).json({ error: 'Invalid password' });

    const token = jwt.sign({ sub: user.id }, SECRET_KEY, { expiresIn: '1h' });
    res.json({ token });
});

// CRUD for Vulnerabilities
app.get('/vulnerabilities', async(req, res) => {
    const vulnerabilities = await prisma.vulnerability.findMany();
    res.json(vulnerabilities);
});

app.post('/vulnerabilities', authenticate, async(req, res) => {
    try {
        const vulnerability = await prisma.vulnerability.create({
            data: req.body
        });
        res.json(vulnerability);
    } catch (error) {
        res.status(400).json({ error: error.message });
    }
});

app.put('/vulnerabilities/:id', authenticate, async(req, res) => {
    try {
        const vulnerability = await prisma.vulnerability.update({
            where: { id: parseInt(req.params.id) },
            data: req.body
        });
        res.json(vulnerability);
    } catch (error) {
        res.status(400).json({ error: error.message });
    }
});

app.delete('/vulnerabilities/:id', authenticate, async(req, res) => {
    try {
        await prisma.vulnerability.delete({ where: { id: parseInt(req.params.id) } });
        res.json({ message: 'Vulnerability deleted successfully' });
    } catch (error) {
        res.status(400).json({ error: error.message });
    }
});

// Error handling
app.use((err, req, res, next) => {
    console.error(err.stack);
    res.status(500).send('Something broke!');
});

const PORT = 3000;
app.listen(PORT, () => {
    console.log(`Server started on http://localhost:${PORT}`);
});