const express = require('express');
const cors = require('cors');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const GhostContentAPI = require('@tryghost/content-api');
const { PrismaClient } = require('@prisma/client');
const morgan = require('morgan');
const axios = require('axios');
require("dotenv").config();

const app = express();
const prisma = new PrismaClient();
const SECRET_KEY = process.env.SECRET_KEY;
const NVD_API_KEY = process.env.NVD_API_KEY;
const contentAPI = new GhostContentAPI({
    url: 'https://demo.ghost.io/ghost/api/content/posts',
    key: '22444f78447824223cefc48062',
    version: 'v5.0'
});

app.use(cors());
app.use(express.json());
app.use(morgan('tiny'));

function authenticate(req, res, next) {
    const authHeader = req.headers.authorization;
    if (authHeader) {
        const token = authHeader.split(' ')[1];
        jwt.verify(token, SECRET_KEY, (err, user) => {
            if (err) {
                return res.sendStatus(403);
            }
            req.user = user;
            next();
        });
    } else {
        res.sendStatus(401);
    }
}

app.get('/', (req, res) => {
    res.send('Vulnerability DB API');
});

// app.post('/register', async(req, res) => {
//     try {
//         const hashedPassword = await bcrypt.hash(req.body.password, 10);
//         const user = await prisma.user.create({
//             data: {
//                 email: req.body.email,
//                 password: hashedPassword
//             }
//         });
//         res.json({ message: 'User registered successfully' });
//     } catch (error) {
//         res.status(400).json({ error: error.message });
//     }
// });

// app.post('/login', async(req, res) => {
//     const user = await prisma.user.findUnique({ where: { email: req.body.email } });
//     if (!user) return res.status(400).json({ error: 'User not found' });

//     const valid = await bcrypt.compare(req.body.password, user.password);
//     if (!valid) return res.status(400).json({ error: 'Invalid password' });

//     const token = jwt.sign({ sub: user.id }, SECRET_KEY, { expiresIn: '1h' });
//     res.json({ token });
// });

// // Fetch vulnerabilities from NVD
// app.get('/vulnerabilities', async(req, res) => {
//     try {
//         const baseURL = 'https://services.nvd.nist.gov/rest/json/cves/2.0';
//         const params = {
//             cpeName: req.query.cpeName,
//             cveId: req.query.cveId,
//             cvssV2Metrics: req.query.cvssV2Metrics,
//             cvssV2Severity: req.query.cvssV2Severity,
//             cvssV3Metrics: req.query.cvssV3Metrics,
//             cvssV3Severity: req.query.cvssV3Severity,
//             cweId: req.query.cweId,
//             hasCertAlerts: req.query.hasCertAlerts,
//             hasCertNotes: req.query.hasCertNotes,
//             hasKev: req.query.hasKev,
//             hasOval: req.query.hasOval,
//             isVulnerable: req.query.isVulnerable,
//             keywordExactMatch: req.query.keywordExactMatch,
//             keywordSearch: req.query.keywordSearch,
//             lastModStartDate: req.query.lastModStartDate,
//             lastModEndDate: req.query.lastModEndDate,
//             noRejected: req.query.noRejected,
//             pubStartDate: req.query.pubStartDate,
//             pubEndDate: req.query.pubEndDate,
//             resultsPerPage: req.query.resultsPerPage || 50,
//             startIndex: req.query.startIndex,
//             sourceIdentifier: req.query.sourceIdentifier,
//             versionEnd: req.query.versionEnd,
//             versionEndType: req.query.versionEndType,
//             versionStart: req.query.versionStart,
//             versionStartType: req.query.versionStartType,
//             virtualMatchString: req.query.virtualMatchString
//         };

//         const response = await axios.get(baseURL, {
//             headers: {
//                 'API-KEY': NVD_API_KEY
//             },
//             params: params
//         });
//         res.json(response.data);
//     } catch (error) {
//         res.status(500).json({ error: error.message });
//     }
// });

// // Fetch specific vulnerability details using query parameter
// app.get('/vulnerability', async(req, res) => {
//     const cveId = req.query.cveId;

//     if (!cveId) {
//         return res.status(400).json({ error: 'cveId query parameter is required.' });
//     }

//     try {
//         const response = await axios.get(`https://services.nvd.nist.gov/rest/json/cves/2.0?cveId=${cveId}`, {
//             headers: {
//                 'API-KEY': NVD_API_KEY
//             }
//         });

//         if (response.data && response.data.CVE_Items && response.data.CVE_Items[0]) {
//             res.json(response.data.CVE_Items[0]);
//         } else {
//             throw new Error('Unexpected response structure from NVD service.');
//         }
//     } catch (error) {
//         if (error.response && error.response.data) {
//             console.error("Detailed error from NVD service:", error.response.data);
//         } else {
//             console.error("Error:", error.message);
//         }
//         res.status(500).json({ error: 'Failed to fetch vulnerability details' });
//     }
// });






app.get('/blogs', async(req, res) => {
    try {
        const blogs = await contentAPI.posts.browse();
        res.json(blogs);
    } catch (error) {
        res.status(400).json({ error: error.message });
    }
});


// CRUD for Educational Resources
// app.get('/resources', async(req, res) => {
//     try {
//         const resources = await prisma.resource.findMany();
//         res.json(resources);
//     } catch (error) {
//         res.status(400).json({ error: error.message });
//     }
// });

// app.post('/resources', authenticate, async(req, res) => {
//     try {
//         const resource = await prisma.resource.create({
//             data: {
//                 title: req.body.title,
//                 link: req.body.link,
//                 description: req.body.description
//             }
//         });
//         res.json(resource);
//     } catch (error) {
//         res.status(400).json({ error: error.message });
//     }
// });

// app.put('/resources/:id', authenticate, async(req, res) => {
//     try {
//         const resource = await prisma.resource.update({
//             where: { id: parseInt(req.params.id) },
//             data: req.body
//         });
//         res.json(resource);
//     } catch (error) {
//         res.status(400).json({ error: error.message });
//     }
// });

// app.delete('/resources/:id', authenticate, async(req, res) => {
//     try {
//         await prisma.resource.delete({ where: { id: parseInt(req.params.id) } });
//         res.json({ message: 'Resource deleted successfully' });
//     } catch (error) {
//         res.status(400).json({ error: error.message });
//     }
// });


app.get('/search', async(req, res) => {
    const searchTerm = req.query.term.toLowerCase();

    let matchedVulnerabilities = [];

    // Fetch from external API
    try {
        const response = await axios.get('https://services.nvd.nist.gov/rest/json/cves/2.0', {
            params: {
                query: searchTerm
            }
        });
        matchedVulnerabilities = response.data; // or whatever the structure is
    } catch (error) {
        console.error("Error fetching vulnerabilities from external API:", error);
    }

    // Combine with your database search if necessary:
    matchedVulnerabilities = matchedVulnerabilities.concat(
        vulnerabilities.filter(vuln =>
            vuln.cve.id.toLowerCase().includes(searchTerm) ||
            vuln.cve.descriptions[0].value.toLowerCase().includes(searchTerm)
        )
    );

    const matchedBlogs = blogs.filter(blog =>
        blog.title.toLowerCase().includes(searchTerm) ||
        blog.content.toLowerCase().includes(searchTerm)
    );

    const matchedResources = resources.filter(resource =>
        resource.title.toLowerCase().includes(searchTerm) ||
        resource.description.toLowerCase().includes(searchTerm)
    );

    res.json({
        vulnerabilities: matchedVulnerabilities,
        blogs: matchedBlogs,
        resources: matchedResources
    });
});

app.use((err, req, res, next) => {
    if (err instanceof SyntaxError && err.status === 400 && 'body' in err) {
        res.status(400).send({ error: 'Bad Request' });
    } else {
        next(err);
    }
});

app.use((err, req, res, next) => {
    console.error(err.stack);
    res.status(err.status || 500).send({ error: err.message || 'Internal Server Error' });
});

const PORT = 3000;
app.listen(PORT, () => {
    console.log(`Server started on http://localhost:${PORT}`);
});