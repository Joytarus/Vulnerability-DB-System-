const express = require('express');
const cors = require('cors');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const { PrismaClient } = require('@prisma/client');
const morgan = require('morgan'); // for logging
require("dotenv").config();

const app = express();
const prisma = new PrismaClient();
const SECRET_KEY = process.env.SECRET_KEY; // You should use a more secure key and store it securely

app.use(cors());
app.use(express.json());
app.use(morgan('tiny')); // Logging middleware

// Middleware to check JWT token
function authenticate(req, res, next) {
    const authHeader = req.headers.authorization;
    if (authHeader) {
        const token = authHeader.split(' ')[1];
        jwt.verify(token, SECRET_KEY, (err, user) => {
            if (err) {
                return res.sendStatus(403);
            }
            req.user = user;
            next();
        });
    } else {
        res.sendStatus(401);
    }
}

// Basic endpoint
app.get('/', (req, res) => {
    res.send('Vulnerability DB API');
});

// User Registration
app.post('/register', async(req, res) => {
    try {
        const hashedPassword = await bcrypt.hash(req.body.password, 10);
        const user = await prisma.user.create({
            data: {
                email: req.body.email,
                password: hashedPassword
            }
        });
        res.json({ message: 'User registered successfully' });
    } catch (error) {
        res.status(400).json({ error: error.message });
    }
});

// User Login
app.post('/login', async(req, res) => {
    const user = await prisma.user.findUnique({ where: { email: req.body.email } });
    if (!user) return res.status(400).json({ error: 'User not found' });

    const valid = await bcrypt.compare(req.body.password, user.password);
    if (!valid) return res.status(400).json({ error: 'Invalid password' });

    const token = jwt.sign({ sub: user.id }, SECRET_KEY, { expiresIn: '1h' });
    res.json({ token });
});

// CRUD for Vulnerabilities
app.get('/vulnerabilities', async(req, res) => {
    const vulnerabilities = await prisma.vulnerability.findMany();
    res.json(vulnerabilities);
});

app.post('/vulnerabilities', authenticate, async(req, res) => {
    try {
        const vulnerability = await prisma.vulnerability.create({
            data: req.body
        });
        res.json(vulnerability);
    } catch (error) {
        res.status(400).json({ error: error.message });
    }
});

app.put('/vulnerabilities/:id', authenticate, async(req, res) => {
    try {
        const vulnerability = await prisma.vulnerability.update({
            where: { id: parseInt(req.params.id) },
            data: req.body
        });
        res.json(vulnerability);
    } catch (error) {
        res.status(400).json({ error: error.message });
    }
});

app.delete('/vulnerabilities/:id', authenticate, async(req, res) => {
    try {
        await prisma.vulnerability.delete({ where: { id: parseInt(req.params.id) } });
        res.json({ message: 'Vulnerability deleted successfully' });
    } catch (error) {
        res.status(400).json({ error: error.message });
    }
});


// CRUD for Blogs
app.get('/blogs', async(req, res) => {
    try {
        const blogs = await prisma.blog.findMany();
        res.json(blogs);
    } catch (error) {
        res.status(400).json({ error: error.message });
    }
});

app.post('/blogs', authenticate, async(req, res) => {
    try {
        // Assuming your authenticate middleware sets the authenticated user's ID as `req.userId`
        const userId = req.userId;

        // Check if the user exists (this is optional but can prevent issues if the userId is somehow invalid)
        const user = await prisma.user.findUnique({ where: { id: userId } });
        if (!user) {
            return res.status(404).json({ error: "User not found" });
        }

        const newBlog = await prisma.blog.create({
            data: {
                title: req.body.title,
                content: req.body.content,
                author: {
                    connect: { id: userId } // This creates a relation between the blog and the user using the userId
                },
                publishedDate: req.body.publishedDate
            }
        });

        res.json(newBlog);
    } catch (error) {
        res.status(400).json({ error: error.message });
    }
});



app.put('/blogs/:id', authenticate, async(req, res) => {
    try {
        const blog = await prisma.blog.update({
            where: { id: parseInt(req.params.id) },
            data: req.body
        });
        res.json(blog);
    } catch (error) {
        res.status(400).json({ error: error.message });
    }
});

app.delete('/blogs/:id', authenticate, async(req, res) => {
    try {
        await prisma.blog.delete({ where: { id: parseInt(req.params.id) } });
        res.json({ message: 'Blog deleted successfully' });
    } catch (error) {
        res.status(400).json({ error: error.message });
    }
});

// CRUD for Educational Resources
app.get('/resources', async(req, res) => {
    try {
        const resources = await prisma.resource.findMany();
        res.json(resources);
    } catch (error) {
        res.status(400).json({ error: error.message });
    }
});

app.post('/resources', authenticate, async(req, res) => {
    try {
        const resource = await prisma.resource.create({
            data: {
                title: req.body.title,
                link: req.body.link,
                description: req.body.description
            }
        });
        res.json(resource);
    } catch (error) {
        res.status(400).json({ error: error.message });
    }
});

app.put('/resources/:id', authenticate, async(req, res) => {
    try {
        const resource = await prisma.resource.update({
            where: { id: parseInt(req.params.id) },
            data: req.body
        });
        res.json(resource);
    } catch (error) {
        res.status(400).json({ error: error.message });
    }
});

app.delete('/resources/:id', authenticate, async(req, res) => {
    try {
        await prisma.resource.delete({ where: { id: parseInt(req.params.id) } });
        res.json({ message: 'Resource deleted successfully' });
    } catch (error) {
        res.status(400).json({ error: error.message });
    }
});


// Error handling: Specific for API validation errors
app.use((err, req, res, next) => {
    if (err instanceof SyntaxError && err.status === 400 && 'body' in err) {
        res.status(400).send({ error: 'Bad Request' });
    } else {
        next(err);
    }
});

// General Error Handling
app.use((err, req, res, next) => {
    console.error(err.stack);
    res.status(err.status || 500).send({ error: err.message || 'Internal Server Error' });
});


const PORT = 3000;
app.listen(PORT, () => {
    console.log(`Server started on http://localhost:${PORT}`);
});